# AST LLVM code generation

Based on the Abstract Syntactic Tree, LLVM code will be generated so that it can be compiled to assembly and then, to machine code. The development process will follow a strategic bottom up approach so that partial results can be effectively tested and validated.

## Metodology

Clang enables compilation to LLVM code on the presence of the flag `-emit-llvm`. Based on examples of C programs being compiled to LLVM by this process, it will be learnt how Monga should be compiled to LLVM, since it is a subset of C.

Compiling `temp.c` to `temp.ll` is done by the following command.

```sh
$ clang -emit-llvm -S temp.c
```

Be aware that much of the extra LLVM code that is generated by Clang won't be replicated for the sake of simplicity. This lack of extra code which describes the program and the computer architecture can lead to less optimal code.

## `def_variable`

A variable definition in LLVM is very simple. It follows this pattern:

```llvm
@<name> = internal global <type> <value>
```

It is `internal` because the variable is visible only to that specific translation unit. It works like `static` in C. Global variables, on the other hand, would be declared with `common`.

`<type>` is a LLVM type descriptor.

For simplicity and possibly more optimal code, `<value>` will always be `undef`.

## `def_type`

There are three kinds of type descriptors.

### `builtin_typedesc`

The mapping between Monga and LLVM built-in types is described in the following table.

| Monga | LLVM |
| :-: | :-: |
| `int` | `i32` |
| `float` | `float` |

### `id_typedesc`

This is simply an alias. The first non-alias typedescriptor will be used.

### `array_typedesc`

This will simply be the array subtype followed by an asterisk (`*`).

### `record_typedesc`

This will need to follow the structured type syntax:

```llvm
%<name> = type { [<type>] }
```

where `[<type>]` represents a list of type descriptors, joined with a `,`.

## `def_function`

Function definitions follow this basic pattern:

```llvm
define <return-type> @<function-name> ([<type> %<reg>]) {
    [%<stack-reg> = alloca <type>]
    [store <type> %<param-reg>, <type>* %<stack-reg>]
    {block}
    ret <return-type> <value>
}
```

First the parameters must be allocated to the stack using `alloca`. Then, the values must be stored in these locations using `store`. Having loaded the parameters to the stack, begins the block code.

In the end, is returned a default value, `undef`, which is reached only if there is return statement at the end of the function block.

## `block`

The block is layed out as such:

```llvm
[%<stack-reg> = alloca <type>]
[{statement}]
```

In the beginning are allocated to the stack all the variable definitions. Then, all the statements follow.

## `statement`

The code generated for a statement greatly differs by kind.

### `if_stmt`

The if statement can be generated using labels, conditional and unconditional jumps. The condition sets a boolean value in a temporary variable which is evaluated in the `br` instruction.

With an else statement, the code looks like such:

```llvm
{condition then=%l<then> else=%l<else>}
l<then>:
{then-block}
br label $l<endif>
l<else>:
{else-block}
br label $l<endif>
l<endif>:
```

And without an else statement, the code looks like such:

```llvm
{condition then=%l<then> else=%l<endif>}
l<then>:
{then-block}
br label $l<endif>
l<endif>:
```

### `while_stmt`

The while statement can be generated using labels and conditional jumps.

```llvm
{condition then=%l<do> else=%l<done>}
l<do>:
{loop-block}
{condition then=%l<do> else=%l<done>}
l<done>:
```

### `assign_stmt`

The assignament statement involves an expresion and a variable and consists of storing the value evaluated in the location pointed by the variable address in memory. The code for this is layed out as such:

```llvm
{variable}
{expression}
store <type> %<exp-reg>, <type>* %<var-reg>
```

Note that the expression and the variable must have the same type. This is particularly true for the Monga semantics. Assigning, say, a float value to an integer variable will throw a type error.

### `return_stmt`

Since functions may not return a value, there are two natures of return statements. Both mean to exit the function, but may return a value as well, depending on the function type.

That is, if the function returns a value, the return statement follows this pattern...

```llvm
{expression}
ret <type> %<exp-reg>
```

...and if does not return a value, the return statement is always...

```llvm
ret void
```

### `call_stmt`

The code for the call statement is the same as the one for the call itself.

```
{call}
```

### `print_stmt`

Printing an expression is done by calling `printf` with the right format string and the expression value.

```llvm
%t<str> = getelementptr inbounds [<strsize> x i8], [<strsize> x i8]* @<strname>, i64 0, i64 0
call i32 (i8*, ...) @printf(i8* %t<str>, <type> %t<exp-reg>)
...
@<strname> = constant [<strsize> x i8] c"..."
```

Even though `printf` returns an integer, this value won't be used in Monga because printing is a statement, and not an expression.

The special characters are printed in hexadecimal as `\XX`, such as `\00` (null) and `\0A` (new line). Printable characters are displayed normally.

### `block_stmt`

The code for the block is simply:

```llvm
{block}
```

## `variable`

There are many types of variables, but all of them have one thing in common: they are always pointers to some location in memory. In code, they all have an unique id which points to a LLVM temporary variable.

### `id_var`

When a variable is referenced by its name, it is bound to a variable definition. Since every declaration precedes a definition, the code for the variable definition has already been generated.

In this matter, it is important to note that there are two possible scopes for variable definitions: outside (global) or inside (local) function blocks.

For global variables, the code that references it is simply its name.

```llvm
@<name>
```

For local variables, the code that references it is the variable id.

```llvm
%t<id>
```

### `array_var`

An array is composed of two expressions: the array expression and the index expression. The array expression should have array type and the index expression should have integer type.

First we need to convert the index value from 32-bit integer to 64-bit integer with the instruction `sext`.

Then, we need to calculate the pointer to the element that dists by the value evaluated by the index expression multiplied by the element size. This calculation is made by the instruction `getelementptr`.

```llvm
{array-expression}
{index-expression}
%t<i64-idx> = sext i32 %t<index-exp-reg> to i64
%t<exp> = getelementptr %<array-exp-type>, %<array-exp-type>* %<array-exp-reg>, i64 %t<i64-idx>
```

The pointer that points to the desired element is `%t<exp>`.

### `record_var`

A record variable envolves a record expression and a field reference. The record expression should have record type and the field reference must point to a field contained in that record type.

In order to identify the field in the record, tha `getelementptr` instruction needs its index in the order that they are declared (the first field is indexed by zero).

This instruction requires that first is passed the index of the variable as if the pointer to the record was in fact an array of records. We then pass `i32 0` in order to always point to the first record.

```llvm
{expression}
%t<exp> = getelementptr %<exp-type>, %<exp-type>* $<exp-reg>, i32 0, i32 <field-idx>
```

## `expression`

There are plenty of types of expression. All of them have one thing in common: they can always be evaluated to a value which has a type. In code, they are attached to a unique id which points to a temporary variable.

### `integer_exp`

Since you can't simply assign literals to temporary variables, this is achieved by a simple hack: add the literal with zero.

```llvm
%t<exp> = add i32 <literal>, 0
```

### `float_exp`

Similar to the integer expression, floating point literals can't be assigned to temporary variables directly. But there are extra precautions for representing floating point numbers in LLVM. If the real value cannot be precisely represented in the format, the compiler will throw an error.

Since the floating point type is always internally stored as an `float`, there are no casting problems. But values such as infinity and NAN will throw errors as they aren't contained in the LLVM grammar.

```llvm
%t<exp> = fadd float <literal>, 0.0
```

### `var_exp`

Since every variable has an address, the value stored there can be obtained by the instruction `load`. By definition, both have the same type.

```llvm
{variable}
%t<exp> = load %<var-type>, %<var-type>* %<var-reg>
```

### `call_exp`

As previously discussed in the "Binding" section, call expressions must involve functions which return a value. In this case, the code for the call will generate a temporary variable, which is merely copied to the expression.

```llvm
{call}
```

### `cast_exp`

Cast expressions involve different instructions for diferent type conversions. They involve an expression being cast and a type to which the expression will be cast. It is assured that this cast can occurr, for the program has already passed the binding phase.

If the expression type is the same as the cast type, no code is generated. The value is stored in the expression temporary variable.

If not, then the conversion has the following pattern:

```llvm
%t<exp> = <cvt-instruction> <exp-type> %<exp-reg> to <cast-type>
```

The instruction for each pair of types is show in the table below.

| from | to | instruction |
| :- | :- | :- |
| `int` | `float` | `sitofp` |
| `float` | `int` | `fptosi` |

### `new_exp`

This instruction is equivalent to calling `malloc` with the size of the type. Since `malloc` returns an opaque pointer (in LLVM, `i8*`), it has to be cast to the desired type using `bitcast`.

Allocating a structure containing a 32-bit integer in LLVM is like the following.

```llvm
%struct.X = type { i32 }
define %struct.X* @f() {
  %1 = call i8* @malloc(i64 4)
  %2 = bitcast i8* %1 to %struct.X*
  ret %struct.X* %2
}
```

But we don't need to calculate the size occupied by the type. We can use a little hack with the `getelementptr` instruction.

```llvm
%Size = getelementptr %T, %T* null, i32 1
%SizeI64 = ptrtoint %T* %Size to i64
```

A good compiler will hopefully optimize these through static analysis. Since the type is known for it was declared before, LLVM will easily figure out the appropriate value for `%SizeI64`. 

In general the following code should be generated for a new expression.

```llvm
%t<size> = getelementptr <type>, <type>* null, i32 %t<size-exp-reg>
%t<size-i64> = ptrtoint <type>* %t<size> to i64
%t<ptr> = call i8* @malloc(i64 %t<size-i64>)
%t<exp> = bitcast i8* %t<ptr> to <type>*
```

Note that for single allocations, `%t<size-exp-reg>` is 1.

### `negative_exp`

This instruction is equivalent to `<zero-literal> - <expression>`. The zero literal part varies depending on the expression type. The possible values are laid on the table below.

| type | zero literal |
| :- | :- |
| `int` | `0` |
| `float` | `0.0` |

### `binop_exp`

The binary operations all fall in the same category of expressions because they involve two expressions being manipulated by an arithmetic operator. Even the negative expression falls back to a subtraction with zero.

The general layout of the code generated follows. Note that both expressions must have the same type, which is ensured in the binding phase.

```llvm
{expression1}
{expression2}
%t<exp> = <instruction> %<type> %<exp1-reg> %<exp2-reg>
```

These are the corresponding instructions for each operation and type.

| operation | `i32` | `float` |
| :- | :- | :- |
| + | `add nsw` | `fadd` |
| - | `sub nsw` | `fsub` |
| * | `mul nsw` | `fmul` |
| / | `sdiv` | `fdiv` |

### `conditional_exp`

A conditional expression is a bit tricky. We need first to evaluate the condition, and depending on the result, assign a different value to a temporary variable.

```llvm
{condition then=%l<true> end=%l<false>}
l<true>:
{expression-true}
br label %l<true-end>
l<false>:
{expression false}
br label %l<false-end>
l<true-end>:
br label %l<eval>
l<false-end>:
br label %l<eval>
l<eval>:
%t<exp> = phi <type> [ %l<true-end> %t<true-exp-reg> ] [ %l<false-end> %t<false-exp-reg> ]
```

## `call`

Just like for the return statement, the code to be generated for call depends on the type of function involved. If and only if the function return a value, then there will be an assignment to a temporary value.

If the function returns a value, then the code looks like the following.

```llvm
[{expression}]
%t<exp> = call <ret-type> @<fname>([<exp-type> <exp-reg>])
```

If not, then the code looks like the following. In this case, the call node does not point to any temporary variable. This can be checked only by checking whether the function returns or not.

```llvm
[{expression}]
call void @<fname>([<exp-type> <exp-reg>])
```

## `condition`

There are plenty of types of conditions. All of them have one thing in common: they evaluate detour the control flow to one of two labels. These labels are predetermined so that one label can be targeted by more than one block.

### `exp_binop_cond`

The binary condition of expressions have all the same pattern, but differ of one word only.

```llvm
{expression1}
{expression2}
%t<result> = <type-cmp> <cmp> <type> %t<exp1> %t<exp2>
br i1 %t<result>, label %l<then> %l<else>
```

The `<type-cmp>` varies based on the type of the expressions:

| type | `type-cmp` |
| :- | :- |
| `i32` | `icmp` |
| `float` | `fcmp` |

The `<cmp>` varies by comparison type:

| comparison | `i32` | `float` |
| :- | :- | :- |
| == | `eq` | `oeq` |
| ~= | `ne` | `one` |
| <= | `sle` | `ole` |
| >= | `sge` | `oge` |
| < | `slt` | `olt` |
| > | `sgt` | `ogt` |

### `cond_binop_cond`

The binary condition of conditions deal with short circuit evaluation. This means that you don't always need to evaluate both conditions to deduct its boolean value.

The evaluation of a logical `OR` condition is as such:

```llvm
{condition1 then=%l<then> else=%l<new-id>}
l<new-id>:
{condition2 then=%l<then> else=%l<else>}
```

and the evaluation of a logical `AND` condition is as such:

```llvm
{condition1 then=%l<new-id> else=%l<else>}
l<new-id>:
{condition2 then=%l<then> else=%l<else>}
```

### `cond_unop_cond`

The only type of unary condition is the `NOT` condition. This resolves down to simply swapping `%l<then>` and `%l<else>`. It doesn't get any simpler than that.